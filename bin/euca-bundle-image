#!/usr/bin/env python

# Software License Agreement (BSD License)
#
# Copyright (c) 2008, Regents of the University of California
# All rights reserved.
#
# Redistribution and use of this software in source and binary forms, with or
# without modification, are permitted provided that the following conditions
# are met:
#
#   Redistributions of source code must retain the above
#   copyright notice, this list of conditions and the
#   following disclaimer.
#
#   Redistributions in binary form must reproduce the above
#   copyright notice, this list of conditions and the
#   following disclaimer in the documentation and/or other
#   materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Author: Sunil Soman sunils@cs.ucsb.edu

import getopt, sys, os
import tarfile
import gzip
from xml.dom.minidom import Document
import sha
from M2Crypto import BN, EVP, RSA, util, Rand, m2, X509
from binascii import hexlify, unhexlify

VERSION = "2007-10-10"
BUNDLER_NAME = "euca-tools"
BUNDLER_VERSION = "1.0"
AES = 'AES-128-CBC'

usage_string = """
USAGE
    euca-bundle-image -i, --image image_path -c, --cert cert_path -k, --privatekey private_key_path 
	  -u, --user user 
          [-p, --prefix prefix] [--kernel kernel_id] [--ramdisk ramdisk_id] 
	  [-B, --block-device-mapping mapping] [-d, --destination destination_path] 
	  [--ec2cert ec2cert_path] [-h, --help] [-m, --manual] [-r, --arch target_architecture] 
	  [-b, --batch] [--version]

    Where
        image_path - The path to the file system image to bundle.
	cert_path - The path to the user's PEM encoded RSA public key certificate file.
	private_key_path - The path to the user's PEM encoded RSA private key file.
	user -  The user's EC2 user ID (not the Access Key/Query Key ID).

	prefix - The filename prefix for bundled files. Defaults to image name.
	kernel_id - Id of the default kernel to launch the instance with.
	ramdisk_id - Id of the default ramdisk to launch the instance with.
	mapping - Default block-device-mapping scheme.
	destination_path - The directory to create the bundle in. Defaults to '/tmp'.
	ec2cert_path - The path to the Cloud's X509 public key certificate.
	-h, --help - Display this help message.
	target_architecture - Target architecture ['x86_64' or 'i386'].
	-b, --batch - Run in non-interactive mode.
"""

version_string = """    euca-bundle-image version: 1.0 (BSD)"""

IMAGE_IO_CHUNK = 8 * 1024
IMAGE_SPLIT_CHUNK = IMAGE_IO_CHUNK * 1024;

def usage():
    print usage_string
    sys.exit()

def version():
    print version_string
    sys.exit()

def split_file(file, chunk_size):
    parts = []
    parts_digest = []
    file_size = os.path.getsize(file)
    in_file = open(file, "rb")
    number_parts = int(file_size / chunk_size)
    number_parts += 1
    bytes_read = 0
    for i in range(0, number_parts, 1):
	filename = '%s.%d' % (file, i)
	part_digest = sha.new()
	file_part = open(filename, "wb")
	part_bytes_written = 0
	while part_bytes_written < IMAGE_SPLIT_CHUNK:
	    data = in_file.read(IMAGE_IO_CHUNK)
	    file_part.write(data)
	    part_digest.update(data)
	    data_len = len(data)
	    part_bytes_written += data_len    	    		
	    bytes_read += data_len
	    if bytes_read >= file_size: break
	file_part.close()			
	parts.append(filename)
	parts_digest.append(hexlify(part_digest.digest()))	

    in_file.close()
    return parts, parts_digest
 
def check_image(image_file):
    print 'checking image'
    image_size = os.path.getsize(image_file)
    in_file = open(image_file, "rb")
    sha_image = sha.new()
    while 1:
        buf=in_file.read()
        if not buf:
           break
	sha_image.update(buf)
    return image_size, hexlify(sha_image.digest())

def tar_image(file): 
    print 'tarring image'
    tar_file = '%s.tar' % (file)
    tar = tarfile.open(tar_file, "w")
    tar.add(file)
    tar.close()
    return tar_file

def zip_image(file):
    print 'zipping image'
    file_in = open(file, 'rb')
    gz_file = '%s.gz' % (file)
    gz_out = gzip.open(gz_file, 'wb')
    gz_out.writelines(file_in)
    gz_out.close()
    file_in.close()
    return gz_file

def hexToBytes(hexString):
    bytes = []
    hexString = ''.join(hexString.split(" "))
    for i in range(0, len(hexString), 2):
        bytes.append(chr(int (hexString[i:i+2], 16)))

    return ''.join( bytes )

def encrypt_file(cipher, in_file, out_file) :
    while 1:
        buf=in_file.read()
        if not buf:
           break
        out_file.write(cipher.update(buf))
    out_file.write(cipher.final())
  

def decrypt_file( cipherType, key, iv, in_file, out_file ) :
    dec = DecryptCipher( cipherType, key, iv )
    while 1 :
        data = in_file.read(IMAGE_IO_CHUNK)
        if not data : break
        out_data = dec.update( data )
        out_file.write( out_data )
    final_data = dec.finish()
    out_file.write( final_data )
 
def encrypt_image(file):
    print 'encrypting image'
    enc_file = '%s.enc' % (file)

    key = hex(BN.rand(16 * 8))[2:34]
    print 'key: %s' % (key)
    iv = hex(BN.rand(16 * 8))[2:34]
    print 'iv: %s' % (iv)

    k=EVP.Cipher(alg='aes_128_cbc', key=(key), iv=unhexlify(iv), op=1)

    in_file = open(file)
    out_file = open(enc_file, "wb")
    encrypt_file(k, in_file, out_file)
    in_file.close()
    out_file.close()
    return enc_file, key, iv

def split_image(file): 
    print 'splitting image'  
    return split_file(file, IMAGE_SPLIT_CHUNK) 

def get_verification_string(manifest_string):
    start_mc = manifest_string.find('<machine_configuration>')
    end_mc = manifest_string.find('</machine_configuration>')
    mc_config_string = manifest_string[start_mc:end_mc + 23]
    start_image = manifest_string.find('<image>')
    end_image = manifest_string.find('</image>')
    image_string = manifest_string[start_image:end_image + 8]

    return mc_config_string + image_string

def generate_manifest(parts, parts_digest, file, key, iv, cert_path, ec2cert_path, private_key_path, target_arch, image_size, image_digest, user):
    print 'generating manifest'

    user_pub_key = X509.load_cert(cert_path).get_pubkey().get_rsa()
    cloud_pub_key = X509.load_cert(ec2cert_path).get_pubkey().get_rsa()

    user_encrypted_key = hexlify(user_pub_key.public_encrypt(key, RSA.pkcs1_padding))
    user_encrypted_iv = hexlify(user_pub_key.public_encrypt(iv, RSA.pkcs1_padding))

    cloud_encrypted_key = hexlify(cloud_pub_key.public_encrypt(key, RSA.pkcs1_padding))
    cloud_encrypted_iv = hexlify(cloud_pub_key.public_encrypt(iv, RSA.pkcs1_padding))

    user_priv_key = RSA.load_key(private_key_path)

    manifest_file = '%s.manifest.xml' % (file)
    manifest_out_file = open(manifest_file, "wb")
    doc = Document()
    
    manifest_elem = doc.createElement("manifest")
    doc.appendChild(manifest_elem)

    #version
    version_elem = doc.createElement("version")
    version_value = doc.createTextNode(VERSION)
    version_elem.appendChild(version_value)
    manifest_elem.appendChild(version_elem)
 
    #bundler info
    bundler_elem = doc.createElement("bundler")
    bundler_name_elem = doc.createElement("name")
    bundler_name_value = doc.createTextNode(BUNDLER_NAME)
    bundler_name_elem.appendChild(bundler_name_value)
    bundler_version_elem = doc.createElement("version")
    bundler_version_value = doc.createTextNode(BUNDLER_VERSION)
    bundler_version_elem.appendChild(bundler_version_value)
    bundler_elem.appendChild(bundler_name_elem)
    bundler_elem.appendChild(bundler_version_elem)
    manifest_elem.appendChild(bundler_elem) 

    #machine config
    machine_config_elem = doc.createElement("machine_configuration")
    target_arch_elem = doc.createElement("architecture")
    target_arch_value = doc.createTextNode(target_arch)
    target_arch_elem.appendChild(target_arch_value)
    machine_config_elem.appendChild(target_arch_elem)
    manifest_elem.appendChild(machine_config_elem)

    image_elem = doc.createElement("image")
    manifest_elem.appendChild(image_elem)

    #name
    image_name_elem = doc.createElement("name") 
    image_name_value = doc.createTextNode(file)
    image_name_elem.appendChild(image_name_value)
    image_elem.appendChild(image_name_elem)
 
    #user
    user_elem = doc.createElement("user")
    user_value = doc.createTextNode("%s" % (user))
    user_elem.appendChild(user_value)
    image_elem.appendChild(user_elem)
    
    #type
    #TODO: fixme
    image_type_elem = doc.createElement("type")
    image_type_value = doc.createTextNode("machine")
    image_type_elem.appendChild(image_type_value)
    image_elem.appendChild(image_type_elem) 
    
    #digest
    image_digest_elem = doc.createElement("digest")
    image_digest_elem.setAttribute('algorithm', 'SHA1')
    image_digest_value = doc.createTextNode('%s' % (image_digest))
    image_digest_elem.appendChild(image_digest_value)
    image_elem.appendChild(image_digest_elem) 
    
    #size
    image_size_elem = doc.createElement("size")
    image_size_value = doc.createTextNode("%s" % (image_size))
    image_size_elem.appendChild(image_size_value)
    image_elem.appendChild(image_size_elem)

    #bundled size

    #key, iv
    cloud_encrypted_key_elem = doc.createElement("ec2_encrypted_key")
    cloud_encrypted_key_value = doc.createTextNode("%s" % (cloud_encrypted_key))
    cloud_encrypted_key_elem.appendChild(cloud_encrypted_key_value)
    cloud_encrypted_key_elem.setAttribute("algorithm", AES)
    image_elem.appendChild(cloud_encrypted_key_elem)
    
    user_encrypted_key_elem = doc.createElement("user_encrypted_key")
    user_encrypted_key_value = doc.createTextNode("%s" % (user_encrypted_key))
    user_encrypted_key_elem.appendChild(user_encrypted_key_value)
    user_encrypted_key_elem.setAttribute("algorithm", AES)
    image_elem.appendChild(user_encrypted_key_elem) 

    cloud_encrypted_iv_elem = doc.createElement("ec2_encrypted_iv")
    cloud_encrypted_iv_value = doc.createTextNode("%s" % (cloud_encrypted_iv))
    cloud_encrypted_iv_elem.appendChild(cloud_encrypted_iv_value)
    cloud_encrypted_iv_elem.setAttribute("algorithm", AES)
    image_elem.appendChild(cloud_encrypted_iv_elem)

    user_encrypted_iv_elem = doc.createElement("user_encrypted_iv")
    user_encrypted_iv_value = doc.createTextNode("%s" % (user_encrypted_iv))
    user_encrypted_iv_elem.appendChild(user_encrypted_iv_value)
    user_encrypted_iv_elem.setAttribute("algorithm", AES)
    image_elem.appendChild(user_encrypted_iv_elem) 

    #parts
    parts_elem = doc.createElement("parts")
    parts_elem.setAttribute("count", '%s' % (len(parts)))
    part_number = 0
    for part in parts:
	part_elem = doc.createElement("part")
	filename_elem = doc.createElement("filename")
	filename_value = doc.createTextNode(part)
	filename_elem.appendChild(filename_value)
	part_elem.appendChild(filename_elem)
        #digest
	part_digest_elem = doc.createElement("digest")
	part_digest_elem.setAttribute('algorithm', 'SHA1')
	part_digest_value = doc.createTextNode(parts_digest[part_number])
	part_digest_elem.appendChild(part_digest_value)
	part_elem.appendChild(part_digest_elem)
	part_elem.setAttribute("index", '%s' % (part_number))
	parts_elem.appendChild(part_elem)
        part_number += 1
    image_elem.appendChild(parts_elem)

    manifest_string = doc.toxml()

    string_to_sign = get_verification_string(manifest_string)
    signature_elem = doc.createElement("signature")
    signature_value = doc.createTextNode("%s" % (hexlify(user_priv_key.sign(sha.sha(string_to_sign).digest()))))
    signature_elem.appendChild(signature_value)
    manifest_elem.appendChild(signature_elem)
    manifest_out_file.write(doc.toxml())
    manifest_out_file.close() 

def main():
    try:
        opts, args = getopt.getopt(sys.argv[1:], 'i:c:k:u:hB:d:br:',
                                   ['image=', 'cert=', 'privatekey=', 'user=', 'help',
                                    'kernel=', 'ramdisk=', 'block-device-mapping=', 'destination=', 'ec2cert=', 'arch=', 'batch', 'version', 'debug'])
    except:
        usage()
  
    debug=False 
    image_path=None
    kernel=None
    user=None
    ramdisk=None
    cert_path=None
    private_key_path=None
    prefix=None
    destination_path=None
    ec2cert_path=None
    target_arch='x86_64'
    batch=False
    
    for name, value in opts:
        if name in ('-h', '--help'):
            usage()
        if name in ('-i', '--image'):
            image_path = value
        if name in ('-c', '--cert'):
            cert_path = value
        if name in ('-k', '--privatekey'):
            private_key_path = value
        if name in ('-u', '--user'):
            user = value
        if name in ('--kernel'):
            kernel = value
        if name in ('--ramdisk'):
            ramdisk = value
        if name in ('-p', '--prefix'):
            prefix = value
        if name in ('-d', '--destination'):
            destination_path = value
        if name in ('--ec2cert'):
            ec2cert_path = value
        if name in ('-r', '--arch'):
            target_arch = value
	    print target_arch
	    if target_arch != 'i386' and target_arch != 'x86_64':
		print 'target architecture must be i386 or x86_64'
		usage()
	if name in ('--batch'):
	    batch = True
	if name in ('--version'):
	    version()
	if name in ('--debug'):
	    debug = True

    if image_path and cert_path and private_key_path and user:
	image_size, sha_image_digest = check_image(image_path)
	tar_file = tar_image(image_path)
	zip_file = zip_image(tar_file)
	os.remove(tar_file)
	encrypted_file, key, iv = encrypt_image(zip_file)
	os.remove(zip_file)
	parts, parts_digest = split_image(encrypted_file)
	generate_manifest(parts, parts_digest, image_path, key, iv, cert_path, ec2cert_path, private_key_path, target_arch, image_size, sha_image_digest, user)
    else:
	print 'image, cert, privatekey and user MUST be specified.'
	usage()
if __name__ == "__main__":
    main()
       


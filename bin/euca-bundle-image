#!/usr/bin/env python

# Software License Agreement (BSD License)
#
# Copyright (c) 2009, Eucalyptus Systems, Inc.
# All rights reserved.
#
# Redistribution and use of this software in source and binary forms, with or
# without modification, are permitted provided that the following conditions
# are met:
#
#   Redistributions of source code must retain the above
#   copyright notice, this list of conditions and the
#   following disclaimer.
#
#   Redistributions in binary form must reproduce the above
#   copyright notice, this list of conditions and the
#   following disclaimer in the documentation and/or other
#   materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
# ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
# LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
# CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
# SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# Author: Neil Soman neil@eucalyptus.com

import getopt, sys, os
from euca2ools import Euca2ool, FileValidationError, Util

usage_string = """
USAGE
    euca-bundle-image -i, --image image_path -c, --cert cert_path -k, --privatekey private_key_path 
	-u, --user user 
	[-p, --prefix prefix] [--kernel kernel_id] [--ramdisk ramdisk_id] 
	[-B, --block-device-mapping mapping] [-d, --destination destination_path] 
	[--ec2cert ec2cert_path] [-r, --arch target_architecture] 
	[-b, --batch] [-h, --help] [--version] [--debug] 

    Where
	image_path - The path to the file system image to bundle.
	cert_path - The path to the user's PEM encoded RSA public key certificate file.
	private_key_path - The path to the user's PEM encoded RSA private key file.
	user -  The user's EC2 user ID (not the Access Key/Query Key ID).

	prefix - The filename prefix for bundled files. Defaults to image name.
	kernel_id - Id of the default kernel to launch the instance with.
	ramdisk_id - Id of the default ramdisk to launch the instance with.
	mapping - Default block-device-mapping scheme.
	destination_path - The directory to create the bundle in. Defaults to '/tmp'.
	ec2cert_path - The path to the Cloud's X509 public key certificate.
	target_architecture - Target architecture ['x86_64' or 'i386'].
	-b, --batch - Run in non-interactive mode.
"""

version_string = """    euca-bundle-image version: 1.0 (BSD)"""

def usage():
    print usage_string
    sys.exit()

def version():
    print version_string
    sys.exit()

def get_block_devs(mapping):
    mapping = []
    mapping_pairs = mapping.split(',')
    for m in mapping_pairs:
        m_parts = m.split('=')
        if(len(m_parts) > 1):
            mapping.append(m_parts[0])
            mapping.append(m_parts[1])
    return mapping

def main():
    euca = None
    try:
	euca = Euca2ool('i:c:k:u:B:d:br:p:',
                                   ['image=', 'cert=', 'privatekey=', 'user=', 'prefix=', 
                                    'kernel=', 'ramdisk=', 'block-device-mapping=', 'destination=', 'ec2cert=', 'arch=', 'batch'])
    except:
        usage()
  
    image_path=None
    kernel=None
    user=None
    ramdisk=None
    cert_path=os.getenv('EC2_CERT')
    private_key_path=os.getenv('EC2_PRIVATE_KEY')
    prefix=None
    destination_path='/tmp'
    ec2cert_path=os.getenv('EUCALYPTUS_CERT')
    target_arch='x86_64'
    mapping = None
    batch=False
         
    for name, value in euca.opts:
        if name in ('-h', '--help'):
            usage()
        elif name in ('-i', '--image'):
            image_path = value
        elif name in ('-c', '--cert'):
            cert_path = value
        elif name in ('-k', '--privatekey'):
            private_key_path = value
        elif name in ('-u', '--user'):
	    try:
                user = int(value)
	    except ValueError:
		print 'Invalid user'
		sys.exit()
        elif name == '--kernel':	
            kernel = value
        elif name == '--ramdisk':
            ramdisk = value
        elif name in ('-p', '--prefix'):
            prefix = value
        elif name in ('-d', '--destination'):
            destination_path = value
        elif name == '--ec2cert':
            ec2cert_path = value
        elif name in ('-r', '--arch'):
            target_arch = value
	    print target_arch
	    if target_arch != 'i386' and target_arch != 'x86_64':
		print 'target architecture must be i386 or x86_64'
		usage()
	elif name in ('-B', '--block-device-mapping'):
	    mapping = value
	elif name == '--batch':
	    batch = True
	elif name == '--version':
	    version()

    if image_path and cert_path and private_key_path and user and ec2cert_path:
	try:
	    euca.validate_file(image_path)
	except FileValidationError:
	    print 'Invalid image'
	    sys.exit(1)
	try:
	    euca.validate_file(cert_path)
	except FileValidationError:
	    print 'Invalid cert'
	    sys.exit(1)
	try:
	    euca.validate_file(private_key_path)
	except FileValidationError:
	    print 'Invalid private key'
 	    sys.exit(1)
	try: 
	    euca.validate_file(ec2cert_path)
	except FileValidationError:
	    print 'Invalid ec2cert' 
	    sys.exit(1)

	image_size, sha_image_digest = euca.check_image(image_path, destination_path)
	if not prefix:
            prefix = euca.get_relative_filename(image_path)
	tgz_file = euca.tarzip_image(prefix, image_path, destination_path)
	encrypted_file, key, iv, bundled_size = euca.encrypt_image(tgz_file)
	os.remove(tgz_file)
	parts, parts_digest = euca.split_image(encrypted_file)
        if mapping:
            mapping = get_block_devs(mapping)
	euca.generate_manifest(destination_path, prefix, parts, parts_digest, image_path, key, iv, cert_path, ec2cert_path, private_key_path, target_arch, image_size, bundled_size, sha_image_digest, user, kernel, ramdisk, mapping)
        os.remove(encrypted_file)
    else:
	if not image_path:
	    print 'image be specified.'
	if not cert_path:
	    print 'cert must be specified.'
	if not private_key_path:
	    print 'private key must be specified.'
	if not user:
	    print 'user must be specified.'
	if not ec2cert_path:
	    print 'ec2cert must be specified.'
	usage()
if __name__ == "__main__":
    main()
       

